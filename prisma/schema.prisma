generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// PROJECT HIERARCHY
// ============================================================================

// Projects - Repositories/codebases being worked on
model Project {
  id          Int      @id @default(autoincrement())
  name        String // "devlog"
  fullName    String   @unique // "codervisor/devlog"
  repoUrl     String   @unique // "git@github.com:codervisor/devlog.git"
  repoOwner   String // "codervisor"
  repoName    String // "devlog"
  description String?  @db.Text
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  machines      Machine[]      @relation("MachineProjects")
  workspaces    Workspace[]
  agentEvents   AgentEvent[]
  agentSessions AgentSession[]
  devlogEntries DevlogEntry[]

  @@index([fullName])
  @@index([repoUrl])
  @@map("projects")
}

// Machines - Physical or virtual machines where agents run
model Machine {
  id          Int      @id @default(autoincrement())
  machineId   String   @unique // "marv-macbook-pro-darwin"
  hostname    String // "marv-macbook-pro"
  username    String // "marvzhang"
  osType      String // "darwin", "linux", "windows"
  osVersion   String? // "14.5"
  machineType String // "local", "remote", "cloud", "ci"
  ipAddress   String?
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  lastSeenAt  DateTime @updatedAt @map("last_seen_at") @db.Timestamptz

  // Relations
  projects   Project[]   @relation("MachineProjects")
  workspaces Workspace[]

  @@index([machineId])
  @@index([hostname])
  @@index([machineType])
  @@map("machines")
}

// Workspaces - VS Code windows/folders on specific machines
model Workspace {
  id            Int      @id @default(autoincrement())
  projectId     Int      @map("project_id")
  machineId     Int      @map("machine_id")
  workspaceId   String   @unique @map("workspace_id") // VS Code UUID
  workspacePath String   @map("workspace_path")
  workspaceType String   @map("workspace_type") // "folder", "multi-root"
  branch        String?
  commit        String?
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  lastSeenAt    DateTime @updatedAt @map("last_seen_at") @db.Timestamptz

  // Relations
  project      Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  machine      Machine       @relation(fields: [machineId], references: [id], onDelete: Cascade)
  chatSessions ChatSession[]

  @@unique([projectId, machineId, workspaceId])
  @@index([workspaceId])
  @@index([projectId])
  @@index([machineId])
  @@map("workspaces")
}

// Main devlog entries
model DevlogEntry {
  id          Int       @id @default(autoincrement())
  key         String    @unique @map("key_field")
  title       String
  type        String    @default("task") // DevlogType as string
  description String    @db.Text
  status      String    @default("new") // DevlogStatus as string
  priority    String    @default("medium") // DevlogPriority as string
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  closedAt    DateTime? @map("closed_at") @db.Timestamptz
  archived    Boolean   @default(false)
  assignee    String?
  projectId   Int       @map("project_id")

  // Flattened DevlogContext fields
  businessContext  String? @map("business_context") @db.Text
  technicalContext String? @map("technical_context") @db.Text
  tags             String? @db.Text // JSON array as text
  files            String? @db.Text // JSON array as text
  dependencies     String? @db.Text // JSON array as text

  // Relations
  project           Project            @relation(fields: [projectId], references: [id])
  notes             DevlogNote[]
  dependencies_from DevlogDependency[] @relation("DevlogDependencySource")
  dependencies_to   DevlogDependency[] @relation("DevlogDependencyTarget")
  documents         DevlogDocument[]

  @@index([status])
  @@index([type])
  @@index([priority])
  @@index([assignee])
  @@index([key])
  @@index([projectId])
  @@map("devlog_entries")
}

// Devlog notes - separate table for better relational modeling
model DevlogNote {
  id        String   @id
  devlogId  Int      @map("devlog_id")
  timestamp DateTime @db.Timestamptz
  category  String // DevlogNoteCategory as string
  content   String   @db.Text

  // Relations
  devlogEntry DevlogEntry @relation(fields: [devlogId], references: [id], onDelete: Cascade)

  @@index([devlogId])
  @@index([timestamp])
  @@index([category])
  @@map("devlog_notes")
}

// Devlog dependencies for hierarchical work management
model DevlogDependency {
  id             String  @id
  devlogId       Int     @map("devlog_id")
  type           String // DevlogDependencyType as string
  description    String  @db.Text
  externalId     String? @map("external_id")
  targetDevlogId Int?    @map("target_devlog_id")

  // Relations
  devlogEntry       DevlogEntry  @relation("DevlogDependencySource", fields: [devlogId], references: [id], onDelete: Cascade)
  targetDevlogEntry DevlogEntry? @relation("DevlogDependencyTarget", fields: [targetDevlogId], references: [id], onDelete: SetNull)

  @@index([devlogId])
  @@index([type])
  @@index([targetDevlogId])
  @@map("devlog_dependencies")
}

// Devlog documents
model DevlogDocument {
  id            String   @id
  devlogId      Int      @map("devlog_id")
  filename      String // Internal filename/identifier
  originalName  String   @map("original_name") // Original filename from upload
  mimeType      String   @map("mime_type")
  size          Int // Size in bytes
  type          String // DocumentType as string (text, markdown, image, pdf, etc.)
  textContent   String?  @map("text_content") @db.Text // Extracted text content for searchable documents
  binaryContent Bytes?   @map("binary_content") // Binary content for files
  metadata      Json     @default("{}") // Additional file metadata
  uploadedBy    String?  @map("uploaded_by") // User who uploaded the document
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  devlogEntry DevlogEntry @relation(fields: [devlogId], references: [id], onDelete: Cascade)

  @@index([devlogId])
  @@index([mimeType])
  @@index([type])
  @@index([originalName])
  @@map("devlog_documents")
}

// User management and authentication
model User {
  id              Int       @id @default(autoincrement())
  email           String    @unique
  name            String?
  avatarUrl       String?   @map("avatar_url")
  passwordHash    String    @map("password_hash")
  isEmailVerified Boolean   @default(false) @map("is_email_verified")
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  lastLoginAt     DateTime? @map("last_login_at") @db.Timestamptz

  // Relations
  providers               UserProvider[]
  emailVerificationTokens EmailVerificationToken[]
  passwordResetTokens     PasswordResetToken[]

  @@map("users")
}

// OAuth providers
model UserProvider {
  id         Int    @id @default(autoincrement())
  userId     Int    @map("user_id")
  provider   String
  providerId String @map("provider_id")
  email      String
  name       String
  avatarUrl  String @map("avatar_url")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
  @@map("user_providers")
}

// Email verification tokens
model EmailVerificationToken {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at") @db.Timestamptz
  used      Boolean  @default(false)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("email_verification_tokens")
}

// Password reset tokens
model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at") @db.Timestamptz
  used      Boolean  @default(false)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("password_reset_tokens")
}

// Chat Sessions - Conversation threads within workspaces
model ChatSession {
  id           Int       @id @default(autoincrement())
  sessionId    String    @unique @db.Uuid // From chat session filename
  workspaceId  Int       @map("workspace_id")
  agentType    String    @map("agent_type") // "copilot", "claude", "cursor"
  modelId      String?   @map("model_id") // "gpt-4", "claude-sonnet-4.5"
  startedAt    DateTime  @map("started_at") @db.Timestamptz
  endedAt      DateTime? @map("ended_at") @db.Timestamptz
  messageCount Int       @default(0) @map("message_count")
  totalTokens  Int       @default(0) @map("total_tokens")
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  workspace    Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  chatMessages ChatMessage[]
  AgentEvent   AgentEvent[]

  @@index([sessionId])
  @@index([workspaceId])
  @@index([startedAt(sort: Desc)])
  @@index([agentType])
  @@map("chat_sessions")
}

// Chat Messages - Individual messages in chat sessions
model ChatMessage {
  id            String   @id @db.Uuid
  sessionId     String   @map("session_id") @db.Uuid
  role          String // "user", "assistant"
  content       String   @db.Text
  timestamp     DateTime @db.Timestamptz
  sequence      Int
  metadata      Json     @default("{}")
  searchContent String?  @map("search_content") @db.Text

  // Relations
  session ChatSession @relation(fields: [sessionId], references: [sessionId], onDelete: Cascade)

  @@index([sessionId])
  @@index([timestamp])
  @@index([sessionId, sequence])
  @@map("chat_messages")
}

// ============================================================================
// AGENT OBSERVABILITY - TIME-SERIES DATA
// ============================================================================

// Agent Events - Individual actions (TimescaleDB hypertable)
//
// NOTE: This table is converted to a TimescaleDB hypertable for time-series optimization.
// The conversion is performed by scripts/enable-timescaledb.sql which:
// - Creates a hypertable partitioned by timestamp (1-day chunks)
// - Enables compression after 7 days (70-90% storage reduction)
// - Sets up automatic retention policy (1 year)
// - Creates continuous aggregates for hourly and daily statistics
//
// Performance characteristics:
// - Write throughput: 50-100K events/sec
// - Query latency: 30-50ms P95 for time-range queries
// - Storage: 200-500 bytes per event after compression
//
// See: specs/20251031/001-database-architecture/README.md for details
model AgentEvent {
  id           String   @id @default(uuid()) @db.Uuid
  timestamp    DateTime @db.Timestamptz
  eventType    String   @map("event_type") // AgentEventType as string
  agentId      String   @map("agent_id") // AgentType as string
  agentVersion String   @map("agent_version")
  sessionId    String   @map("session_id") @db.Uuid
  projectId    Int      @map("project_id")

  // Context (JSON)
  context Json @default("{}")

  // Event-specific data (JSON)
  data Json @default("{}")

  // Metrics (JSON)
  metrics Json?

  // Relationships
  parentEventId   String?  @map("parent_event_id") @db.Uuid
  relatedEventIds String[] @map("related_event_ids")

  // Metadata
  tags     String[]
  severity String? // "info", "warning", "error"

  // Relations
  session       AgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  project       Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  ChatSession   ChatSession? @relation(fields: [chatSessionId], references: [id])
  chatSessionId Int?

  // Indexes optimized for TimescaleDB time-series queries
  @@index([timestamp(sort: Desc)]) // Primary time-series index
  @@index([sessionId, timestamp(sort: Desc)]) // Session timeline queries (composite)
  @@index([projectId, timestamp(sort: Desc)]) // Project timeline queries (composite)
  @@index([agentId]) // Filter by agent type
  @@index([eventType]) // Filter by event type
  @@index([tags]) // Array index for tag filtering
  @@index([severity]) // Filter by severity level
  @@index([data]) // GIN index for JSONB field queries (created in migration)
  @@map("agent_events")
}

// Agent sessions - Complete agent working sessions
model AgentSession {
  id           String    @id @default(uuid()) @db.Uuid
  agentId      String    @map("agent_id") // AgentType as string
  agentVersion String    @map("agent_version")
  projectId    Int       @map("project_id")
  startTime    DateTime  @map("start_time") @db.Timestamptz
  endTime      DateTime? @map("end_time") @db.Timestamptz
  duration     Int? // Duration in seconds

  // Context (JSON)
  context Json @default("{}")

  // Metrics (JSON)
  metrics Json @default("{}")

  // Outcome
  outcome      String? // "success", "failure", "partial", "cancelled"
  qualityScore Decimal? @map("quality_score") @db.Decimal(5, 2) // 0-100

  // Relations
  project Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  events  AgentEvent[]

  @@index([startTime(sort: Desc)])
  @@index([agentId])
  @@index([projectId])
  @@index([outcome])
  @@index([qualityScore])
  @@map("agent_sessions")
}

// Note: Enums are now handled as strings for flexibility
// TypeScript types and validation provide the constraints
// This reduces type mapping complexity between Prisma and TypeScript
